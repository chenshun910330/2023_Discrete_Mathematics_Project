[專案研究報告 (PDF)](./Presentation/成果.pdf)

有限集合上遞移關係數量的計數問題 (Transitive Relations Counting)
從暴力法到位元並行優化 (From Naive to Bit-vector Optimization)

這是我在學習離散數學與演算法時製作的專案。主要目標是計算在元素數量為 $n$ 的集合中，總共存在多少個符合「遞移律」的關係矩陣，並探討如何透過位元運算解決組合爆炸帶來的運算效能問題。

📖 研究動機
在課本上學習「遞移律」定義很簡單，但當集合元素增加時，其關係總數會以 $2^{n^2}$ 指數成長。我想透過程式實作來驗證：

1. 理論驗證：產出數據並與 OEIS A006905 序列比對。

2. 效能挑戰：觀察當 $n=6$ 時，高達 687 億次的運算量如何讓普通演算法崩潰，並嘗試優化它。

🛠️ 演算法實作
1. 暴力法 (Naive Approach) - $O(n^3)$

使用三層嵌套迴圈檢查所有的三元組 $(i, k, j)$。雖然邏輯直觀，但在面對大數據時效率極低。

2. 位元並行優化 (Bit-vector Optimization) - $O(n^2)$

這是本專案的核心優化。我將矩陣的每一列存儲為一個位元向量 (Bit-vector)，將原本 $O(n)$ 的內層判斷簡化為一次 CPU 位元運算。

• 優化邏輯： 若 $i \to k$ 成立，則 $k$ 指向的所有元素，$i$ 也必須指向。 在程式中表示為：`if ((Row[k] & Row[i]) != Row[k]) return 非遞移;`

📊 實驗數據彙整
🧪 學習心得與困難克服
• 組合爆炸：第一次體會到指數成長的恐怖，當 $n$ 從 5 變成 6 時，計算量跳了 2048 倍。

• Early Exit 策略：只要發現一個反例就立刻 `return`，在處理幾千萬個矩陣時省下巨大時間。

• 底層細節：在 C 語言中處理位元運算優先權與記憶體映射，讓我對系統底層有更深理解。
